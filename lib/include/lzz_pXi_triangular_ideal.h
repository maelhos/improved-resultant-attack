#ifndef LZZ_PXI_TRIANGULAR_IDEAL__H
#define LZZ_PXI_TRIANGULAR_IDEAL__H
#include "lzz_pXi.h"
#include <cassert>
#include <omp.h>

NTL_CLIENT
/* 
zz_pXi_triangular_ideal<N> represents a polynomial quotient ring (X, z_1, ..., z_N) in the triangular
ideal generated by :

| z_1^alpha - f_1(x)
| z_2^alpha - f_2(x, z_1)
| z_3^alpha - f_3(x, z_1, z_2)
| ... 
| z_n^alpha - f_n(x, z_1, ..., z_n-1)

where for all 1 <= k <= k, for all 1 <= i < k, deg_{z_i}(f_k) <= 2*alpha - 2
*/

extern long heuristic_count;
template <auto alpha, auto N>
class zz_pXi_triangular_ideal
{
public:
    zz_pXi_triangular_ideal<alpha, N-1> base;
    zz_pXi<N> fn;

    zz_pXi_triangular_ideal() {}
    zz_pXi_triangular_ideal(zz_pXi_triangular_ideal<alpha, N - 1>& base, zz_pXi<N>& fn) : base(base), fn(fn) {}

    zz_pXi_triangular_ideal<alpha, N + 1> extend(zz_pXi<N + 1> fnp1)
    {
        reduce(fnp1);
        return zz_pXi_triangular_ideal<alpha, N + 1>(*this, fnp1);
    }

    void reduce(zz_pXi<N + 1>& g) const
    {
        assert(g.degXn() < 2*alpha - 1);
        zz_pXi<N + 1> gr{};

        if (g.degXn() < alpha)
        {
            
            for (long i = 0; i < g.rep.length(); i++)
                base.reduce(g.rep[i]);
            heuristic_count++;
            g.normalize();
            return;
        }

        for (long i = 0; i < alpha; i++)
        {
            zz_pXi<N> reduced{};
            if (g.rep.length() > i + alpha)
            {
                reduced = g.rep[i + alpha];
                base.reduce(reduced);
                mul(reduced, reduced, fn);
            }

            if (g.rep.length() > i)
            {
                add(reduced, reduced, g.rep[i]);
                base.reduce(reduced);
            }

            zz_pXi<N + 1> reduced_shifted{};
            reduced_shifted.rep.SetLength(i + 1);
            reduced_shifted.rep[i].rep = reduced.rep;
            reduced_shifted.normalize();

            add(gr, gr, reduced_shifted);
        }
        g = gr;
        g.normalize();
    }

    inline void mulReduce(zz_pXi<N + 1>&a, const zz_pXi<N + 1>& b, const zz_pXi<N + 1>& c) const
    {
        mul(a, b, c);
        reduce(a);
    }

    inline zz_pXi<N + 1> mulReduce(const zz_pXi<N + 1>& b, const zz_pXi<N + 1>& c) const
    {
        zz_pXi<N + 1> a{};
        mulReduce(a, b, c);
        return a;
    }

    inline void sqrReduce(zz_pXi<N + 1>&a, const zz_pXi<N + 1>& b) const
    {
        sqr(a, b);
        reduce(a);
    }

    inline zz_pXi<N + 1> sqrReduce(const zz_pXi<N + 1>& b) const
    {
        zz_pXi<N + 1> a{};
        sqrReduce(a, b);
        return a;
    }

    ~zz_pXi_triangular_ideal() {}
};

template <auto alpha>
class zz_pXi_triangular_ideal<alpha, 0> 
{
public:
    zz_pXi_triangular_ideal() {}

    zz_pXi_triangular_ideal<alpha, 1> extend(zz_pXi<1> f1)
    {
        return zz_pXi_triangular_ideal<alpha, 1>(*this, f1);
    }

    inline void mulReduce(zz_pXi<1>&a, const zz_pXi<1>& b, const zz_pXi<1>& c) const
    {
        mul(a, b, c);
    }

    inline zz_pXi<1> mulReduce(const zz_pXi<1>& b, const zz_pXi<1>& c) const
    {
        zz_pXi<1> a{};
        mulReduce(a, b, c);
        return a;
    }

    inline void sqrReduce(zz_pXi<1>&a, const zz_pXi<1>& b) const
    {
        sqr(a, b);
    }

    inline zz_pXi<1> sqrReduce(const zz_pXi<1>& b) const
    {
        zz_pXi<1> a{};
        sqrReduce(a, b);
        return a;
    }

    void reduce(zz_pXi<1>& g) const {}

    ~zz_pXi_triangular_ideal() {}
};

#endif